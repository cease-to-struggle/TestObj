创建正则对象
1.实例化构造器：var reg = new RegExp('正则表达式');
2.直接声明正则表达式：var reg = /abc/;

正则相关6大方法：
reg.test(str);检验字符串中是否有复合正则对象描述的字串
reg.exec(str); 捕获字串  返回数组  每调用一次捕获一个结果
    检验字符串中是否含有符合正则对象描述的字串，如果有则捕获起来返回数组结果 每次捕获后指针继续下移
str.search(reg)；  返回字串首次出现位置 如果没有返回-1
str.match(reg);  返回数组，调用一次捕获所有结果
str.replace(reg,str1);  在字符串中，用新字符串替换旧的字符串
str.split(reg);  根据字串把字符串拆分成数组


匹配模式  修正符
g:global  全局匹配  在字符的所有位置尝试匹配
		用法：reg.exec()  str.match()  str.replace() 表达式不加入g，则只处理第一个匹配；如果加入g，处理所有。另外三个方法不受g修正符影响

i:ignore  忽略大小写
		

m:more    多行匹配
		  表明进行多行匹配，但是只用使用^和$模式时才会起作用

s         特殊字符圆点 .包含换行符
U         不重复匹配   只匹配最近的一个字符串
x		  将模式中的空白忽略
A		  强制从目标串开头匹配
D         如果使用$限制结尾字符，则不允许结尾有换行
e		  配合函数preg_replace()使用，可以把匹配来的字符串当做正则执行






常见元字符
\d：匹配数字   \D：匹配非数字  \w： word  匹配单词字符 大写字母 小写字母 下划线 数字
\W:非单词字符   \s:空白字符(空格、换行符、制表符)  \S:非空白字符  .：任意字符（除\n外）
\f：匹配一个换页符  \n：匹配一个换行符  \r：匹配一个回车符  \t：匹配一个制表符  \v：匹配一个垂直制表符

匹配特殊字符  使用\转义   比如\*  \[

^ $  ()  
* 匹配前面子表达式 零次或一次
+ 匹配前面表达式一次或多次
? 匹配前面的子表达式零次或一次
{n} 匹配n次
{n,} 匹配至少n次
{n,m} 至少n 至多m次
？ 当该字符紧跟在现在任何一个限制符后面是，匹配模式是非贪婪的 即尽可能少匹配搜索的字符串
(pattern)  匹配pattren 并获取匹配
(?:pattern) 匹配pattern但不获取匹配结果，不进行存储宫以后使用
(?=pattern) 正向预查  非获取匹配  例如，'Windows (?=95|98|NT|2000)' 能匹配 "Windows 2000" 中的 "Windows" ，但不能匹配 "Windows 3.1" 中的 "Windows"。
(?!pattern) 负向预查 与正向相反
x|y  x或y
[xyz]  匹配包含的任一字符
[^xyz] 匹配未包含的任意字符
[a-z]  匹配范围内的任意字符
[^a-z] 匹配不在范围内的任意字符
\b 	   匹配一个单词的边界  'er\b' =>never 
\B     匹配非单词边界



1、查什么   2、差多少  3、在哪查 （开始 末尾 中间）
